[{"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\index.js":"1","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\App.js":"2","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\robotCommandGenerator.js":"3","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\customBlocks.js":"4","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\useCommandQueue.js":"5","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\agentContext.js":"6","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Scene.js":"7","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\useAgent.js":"8","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\executeCommand.js":"9","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Map.js":"10","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\levelContext.js":"11"},{"size":219,"mtime":1760352187013,"results":"12","hashOfConfig":"13"},{"size":2795,"mtime":1760596956569,"results":"14","hashOfConfig":"13"},{"size":2672,"mtime":1760528295053,"results":"15","hashOfConfig":"13"},{"size":4352,"mtime":1760529817793,"results":"16","hashOfConfig":"13"},{"size":2658,"mtime":1760596956569,"results":"17","hashOfConfig":"13"},{"size":321,"mtime":1760516163636,"results":"18","hashOfConfig":"13"},{"size":10892,"mtime":1760596235014,"results":"19","hashOfConfig":"13"},{"size":6027,"mtime":1760595116882,"results":"20","hashOfConfig":"13"},{"size":2626,"mtime":1760595116882,"results":"21","hashOfConfig":"13"},{"size":2484,"mtime":1760596235014,"results":"22","hashOfConfig":"13"},{"size":3408,"mtime":1760595879696,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"125b5e2",{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"26"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\index.js",[],["48","49"],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\App.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\robotCommandGenerator.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\customBlocks.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\useCommandQueue.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\agentContext.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Scene.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\useAgent.js",["50"],"import { useState, useRef, useCallback } from 'react'\nimport { useLevel } from '../state/levelContext'\n\nconst DIRECTIONS = [\n    { dx: 0, dy: 1 },   // 0 - –≤–≤–µ—Ä—Ö\n    { dx: 1, dy: 0 },   // 1 - –≤–ø—Ä–∞–≤–æ\n    { dx: 0, dy: -1 },  // 2 - –≤–Ω–∏–∑\n    { dx: -1, dy: 0 },  // 3 - –≤–ª–µ–≤–æ\n]\n\nconst DIRECTION_COUNT = DIRECTIONS.length\n\nexport function useAgent({\n    mapWidth,\n    mapHeight,\n    agentRadius = 0.5,\n    steps = 20,\n    duration = 300\n} = {}) {\n    const { grid, canEnterLogical, isAdjacentToPickup, isAdjacentToDropoff } = useLevel();\n    const [agentState, setAgentState] = useState(() => ({\n        // –õ–æ–≥–∏—á–µ—Å–∫–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã –∫–ª–µ—Ç–æ–∫ —Å–µ—Ç–∫–∏ (i, j)\n        // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—Ç–∞—Ä—Ç—É–µ–º –≤ –ª–µ–≤–æ–º –Ω–∏–∂–Ω–µ–º —É–≥–ª—É –∫–∞—Ä—Ç—ã\n        x: 0,\n        y: mapHeight - 1,\n        direction: 1,\n        scaleY: 1\n    }))\n    const [hasCargo, setHasCargo] = useState(false)\n    const agentStateRef = useRef(agentState)\n    agentStateRef.current = agentState\n\n    const animateMove = useCallback(async (to) => {\n        const from = { ...agentStateRef.current }\n        let dDir = ((to.direction - from.direction + DIRECTION_COUNT) % DIRECTION_COUNT)\n        if (dDir > 2) dDir -= DIRECTION_COUNT\n        const dx = to.x - from.x\n        const dy = to.y - from.y\n        for (let step = 1; step <= steps; ++step) {\n            await new Promise(res => setTimeout(res, duration / steps))\n            const t = step / steps\n            const x = from.x + dx * t\n            const y = from.y + dy * t\n            let newDir = (from.direction + dDir * t + DIRECTION_COUNT) % DIRECTION_COUNT\n            setAgentState({ x, y, direction: t < 1 ? newDir : to.direction, scaleY: 1 })\n        }\n        setAgentState({ ...to, scaleY: to.scaleY ?? 1 })\n    }, [steps, duration])\n\n    const animateSquash = useCallback(async ({ minScaleY = 0.6 } = {}) => {\n        const from = { ...agentStateRef.current }\n        const frames = Math.max(4, Math.floor(steps / 2))\n        const half = Math.floor(frames / 2)\n        // –°–∂–∞—Ç—å\n        for (let i = 1; i <= half; i++) {\n            await new Promise(res => setTimeout(res, (duration) / frames))\n            const t = i / half\n            const scaleY = 1 - (1 - minScaleY) * t\n            setAgentState({ ...from, scaleY })\n        }\n        // –í–µ—Ä–Ω—É—Ç—å\n        for (let i = 1; i <= frames - half; i++) {\n            await new Promise(res => setTimeout(res, (duration) / frames))\n            const t = i / (frames - half)\n            const scaleY = minScaleY + (1 - minScaleY) * t\n            setAgentState({ ...from, scaleY })\n        }\n        setAgentState({ ...from, scaleY: 1 })\n    }, [steps, duration])\n\n    const moveForward = useCallback(async (numSteps = 1) => {\n        const totalSteps = Math.max(1, Number.isFinite(numSteps) ? Math.floor(numSteps) : 1)\n        for (let i = 0; i < totalSteps; i++) {\n            const { x, y, direction } = agentStateRef.current\n            const { dx, dy } = DIRECTIONS[direction]\n            const newX = x + dx\n            const newY = y + dy\n            if (!canEnterLogical(newX, newY)) break\n            await animateMove({ x: newX, y: newY, direction })\n            const stepPauseMs = Math.max(50, Math.floor(duration / 3))\n            await new Promise(res => setTimeout(res, stepPauseMs))\n        }\n    }, [animateMove, duration, canEnterLogical])\n\n    const pickUp = useCallback(async () => {\n        if (hasCargo) return;\n        const { x, y } = agentStateRef.current\n        // –ê–≥–µ–Ω—Ç –º–æ–∂–µ—Ç –∞–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å—Å—è –∏ –∏–º–µ—Ç—å –Ω–µ—Ü–µ–ª—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã ‚Äî –æ–∫—Ä—É–≥–ª–∏–º –¥–æ –±–ª–∏–∂–∞–π—à–µ–π –∫–ª–µ—Ç–∫–∏\n        const i = Math.round(x)\n        const j = Math.round(y)\n        const nearPickup = isAdjacentToPickup(i, j)\n        if (nearPickup) {\n            await animateSquash({ minScaleY: 0.55 })\n            setHasCargo(true)\n        }\n    }, [hasCargo, animateSquash, isAdjacentToPickup])\n\n    const dropOff = useCallback(async () => {\n        if (!hasCargo) return;\n        const { x, y } = agentStateRef.current\n        const i = Math.round(x)\n        const j = Math.round(y)\n        const nearDrop = isAdjacentToDropoff(i, j)\n        if (nearDrop) {\n            await animateSquash({ minScaleY: 0.55 })\n            setHasCargo(false)\n            alert(\"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω! üéâ\")\n        }\n    }, [hasCargo, animateSquash, isAdjacentToDropoff])\n\n    const moveBackward = useCallback(async (numSteps = 1) => {\n        const totalSteps = Math.max(1, Number.isFinite(numSteps) ? Math.floor(numSteps) : 1)\n        for (let i = 0; i < totalSteps; i++) {\n            const { x, y, direction } = agentStateRef.current\n            const { dx, dy } = DIRECTIONS[direction]\n            const newX = x - dx\n            const newY = y - dy\n            if (!canEnterLogical(newX, newY)) break\n            await animateMove({ x: newX, y: newY, direction })\n            const stepPauseMs = Math.max(50, Math.floor(duration / 3))\n            await new Promise(res => setTimeout(res, stepPauseMs))\n        }\n    }, [animateMove, duration, canEnterLogical])\n\n    const turnLeft = useCallback(async () => {\n        const { x, y, direction } = agentStateRef.current\n        const newDir = (direction + DIRECTION_COUNT - 1) % DIRECTION_COUNT\n        await animateMove({ x, y, direction: newDir })\n    }, [animateMove])\n\n    const turnRight = useCallback(async () => {\n        const { x, y, direction } = agentStateRef.current\n        const newDir = (direction + 1) % DIRECTION_COUNT\n        await animateMove({ x, y, direction: newDir })\n    }, [animateMove])\n\n    const getPos = useCallback(() => agentStateRef.current, [])\n\n    return {\n        agentState,\n        agentControls: {\n            moveForward,\n            moveBackward,\n            turnLeft,\n            turnRight,\n            pickUp,\n            dropOff,\n            getPos,\n        }\n    }\n}\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\executeCommand.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Map.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\levelContext.js",[],{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","replacedBy":"54"},{"ruleId":"55","severity":1,"message":"56","line":20,"column":13,"nodeType":"57","messageId":"58","endLine":20,"endColumn":17},"no-native-reassign",["59"],"no-negated-in-lhs",["60"],"no-unused-vars","'grid' is assigned a value but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]