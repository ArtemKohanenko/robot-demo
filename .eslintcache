[{"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\index.js":"1","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\App.js":"2","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\robotCommandGenerator.js":"3","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\customBlocks.js":"4","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\useCommandQueue.js":"5","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\agentContext.js":"6","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Scene.js":"7","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\useAgent.js":"8","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\executeCommand.js":"9","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Map.js":"10","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\levelContext.js":"11","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\index.js":"12","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\App.js":"13","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\blockly\\robotCommandGenerator.js":"14","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\blockly\\customBlocks.js":"15","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\interpreter\\executeCommand.js":"16","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Scene.js":"17","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\levelContext.js":"18","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\interpreter\\useCommandQueue.js":"19","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\useAgent.js":"20","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\agentContext.js":"21","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Map.js":"22","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\userContext.js":"23","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Camera.js":"24","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\components\\Onboarding.js":"25"},{"size":219,"mtime":1760352187013,"results":"26","hashOfConfig":"27"},{"size":2795,"mtime":1760596956569,"results":"28","hashOfConfig":"27"},{"size":2672,"mtime":1760528295053,"results":"29","hashOfConfig":"27"},{"size":4352,"mtime":1760529817793,"results":"30","hashOfConfig":"27"},{"size":2658,"mtime":1760596956569,"results":"31","hashOfConfig":"27"},{"size":321,"mtime":1760516163636,"results":"32","hashOfConfig":"27"},{"size":10892,"mtime":1760596235014,"results":"33","hashOfConfig":"27"},{"size":6027,"mtime":1760595116882,"results":"34","hashOfConfig":"27"},{"size":2626,"mtime":1760595116882,"results":"35","hashOfConfig":"27"},{"size":2484,"mtime":1760596235014,"results":"36","hashOfConfig":"27"},{"size":3408,"mtime":1760595879696,"results":"37","hashOfConfig":"27"},{"size":219,"mtime":1760960974426,"results":"38","hashOfConfig":"39"},{"size":3075,"mtime":1760965373562,"results":"40","hashOfConfig":"39"},{"size":2672,"mtime":1760673826148,"results":"41","hashOfConfig":"39"},{"size":4352,"mtime":1760673826148,"results":"42","hashOfConfig":"39"},{"size":2626,"mtime":1760673826148,"results":"43","hashOfConfig":"39"},{"size":8175,"mtime":1760952258267,"results":"44","hashOfConfig":"39"},{"size":5438,"mtime":1760966518247,"results":"45","hashOfConfig":"39"},{"size":2658,"mtime":1760673826148,"results":"46","hashOfConfig":"39"},{"size":6356,"mtime":1760965639409,"results":"47","hashOfConfig":"39"},{"size":321,"mtime":1760673826148,"results":"48","hashOfConfig":"39"},{"size":2462,"mtime":1760675084033,"results":"49","hashOfConfig":"39"},{"size":2439,"mtime":1760678440964,"results":"50","hashOfConfig":"51"},{"size":8316,"mtime":1760943996941,"results":"52","hashOfConfig":"39"},{"size":2670,"mtime":1761028603009,"results":"53","hashOfConfig":"39"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},"125b5e2",{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"56"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},"jrasqq",{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"93","usedDeprecatedRules":"80"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"102","messages":"103","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"104"},"6r85av",{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\index.js",[],["109","110"],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\App.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\robotCommandGenerator.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\customBlocks.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\useCommandQueue.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\agentContext.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Scene.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\useAgent.js",["111"],"import { useState, useRef, useCallback } from 'react'\nimport { useLevel } from '../state/levelContext'\n\nconst DIRECTIONS = [\n    { dx: 0, dy: 1 },   // 0 - вверх\n    { dx: 1, dy: 0 },   // 1 - вправо\n    { dx: 0, dy: -1 },  // 2 - вниз\n    { dx: -1, dy: 0 },  // 3 - влево\n]\n\nconst DIRECTION_COUNT = DIRECTIONS.length\n\nexport function useAgent({\n    mapWidth,\n    mapHeight,\n    agentRadius = 0.5,\n    steps = 20,\n    duration = 300\n} = {}) {\n    const { grid, canEnterLogical, isAdjacentToPickup, isAdjacentToDropoff } = useLevel();\n    const [agentState, setAgentState] = useState(() => ({\n        // Логические координаты: целочисленные индексы клеток сетки (i, j)\n        // По умолчанию стартуем в левом нижнем углу карты\n        x: 0,\n        y: mapHeight - 1,\n        direction: 1,\n        scaleY: 1\n    }))\n    const [hasCargo, setHasCargo] = useState(false)\n    const agentStateRef = useRef(agentState)\n    agentStateRef.current = agentState\n\n    const animateMove = useCallback(async (to) => {\n        const from = { ...agentStateRef.current }\n        let dDir = ((to.direction - from.direction + DIRECTION_COUNT) % DIRECTION_COUNT)\n        if (dDir > 2) dDir -= DIRECTION_COUNT\n        const dx = to.x - from.x\n        const dy = to.y - from.y\n        for (let step = 1; step <= steps; ++step) {\n            await new Promise(res => setTimeout(res, duration / steps))\n            const t = step / steps\n            const x = from.x + dx * t\n            const y = from.y + dy * t\n            let newDir = (from.direction + dDir * t + DIRECTION_COUNT) % DIRECTION_COUNT\n            setAgentState({ x, y, direction: t < 1 ? newDir : to.direction, scaleY: 1 })\n        }\n        setAgentState({ ...to, scaleY: to.scaleY ?? 1 })\n    }, [steps, duration])\n\n    const animateSquash = useCallback(async ({ minScaleY = 0.6 } = {}) => {\n        const from = { ...agentStateRef.current }\n        const frames = Math.max(4, Math.floor(steps / 2))\n        const half = Math.floor(frames / 2)\n        // Сжать\n        for (let i = 1; i <= half; i++) {\n            await new Promise(res => setTimeout(res, (duration) / frames))\n            const t = i / half\n            const scaleY = 1 - (1 - minScaleY) * t\n            setAgentState({ ...from, scaleY })\n        }\n        // Вернуть\n        for (let i = 1; i <= frames - half; i++) {\n            await new Promise(res => setTimeout(res, (duration) / frames))\n            const t = i / (frames - half)\n            const scaleY = minScaleY + (1 - minScaleY) * t\n            setAgentState({ ...from, scaleY })\n        }\n        setAgentState({ ...from, scaleY: 1 })\n    }, [steps, duration])\n\n    const moveForward = useCallback(async (numSteps = 1) => {\n        const totalSteps = Math.max(1, Number.isFinite(numSteps) ? Math.floor(numSteps) : 1)\n        for (let i = 0; i < totalSteps; i++) {\n            const { x, y, direction } = agentStateRef.current\n            const { dx, dy } = DIRECTIONS[direction]\n            const newX = x + dx\n            const newY = y + dy\n            if (!canEnterLogical(newX, newY)) break\n            await animateMove({ x: newX, y: newY, direction })\n            const stepPauseMs = Math.max(50, Math.floor(duration / 3))\n            await new Promise(res => setTimeout(res, stepPauseMs))\n        }\n    }, [animateMove, duration, canEnterLogical])\n\n    const pickUp = useCallback(async () => {\n        if (hasCargo) return;\n        const { x, y } = agentStateRef.current\n        // Агент может анимироваться и иметь нецелые координаты — округлим до ближайшей клетки\n        const i = Math.round(x)\n        const j = Math.round(y)\n        const nearPickup = isAdjacentToPickup(i, j)\n        if (nearPickup) {\n            await animateSquash({ minScaleY: 0.55 })\n            setHasCargo(true)\n        }\n    }, [hasCargo, animateSquash, isAdjacentToPickup])\n\n    const dropOff = useCallback(async () => {\n        if (!hasCargo) return;\n        const { x, y } = agentStateRef.current\n        const i = Math.round(x)\n        const j = Math.round(y)\n        const nearDrop = isAdjacentToDropoff(i, j)\n        if (nearDrop) {\n            await animateSquash({ minScaleY: 0.55 })\n            setHasCargo(false)\n            alert(\"🎉 Поздравляем! Уровень пройден! 🎉\")\n        }\n    }, [hasCargo, animateSquash, isAdjacentToDropoff])\n\n    const moveBackward = useCallback(async (numSteps = 1) => {\n        const totalSteps = Math.max(1, Number.isFinite(numSteps) ? Math.floor(numSteps) : 1)\n        for (let i = 0; i < totalSteps; i++) {\n            const { x, y, direction } = agentStateRef.current\n            const { dx, dy } = DIRECTIONS[direction]\n            const newX = x - dx\n            const newY = y - dy\n            if (!canEnterLogical(newX, newY)) break\n            await animateMove({ x: newX, y: newY, direction })\n            const stepPauseMs = Math.max(50, Math.floor(duration / 3))\n            await new Promise(res => setTimeout(res, stepPauseMs))\n        }\n    }, [animateMove, duration, canEnterLogical])\n\n    const turnLeft = useCallback(async () => {\n        const { x, y, direction } = agentStateRef.current\n        const newDir = (direction + DIRECTION_COUNT - 1) % DIRECTION_COUNT\n        await animateMove({ x, y, direction: newDir })\n    }, [animateMove])\n\n    const turnRight = useCallback(async () => {\n        const { x, y, direction } = agentStateRef.current\n        const newDir = (direction + 1) % DIRECTION_COUNT\n        await animateMove({ x, y, direction: newDir })\n    }, [animateMove])\n\n    const getPos = useCallback(() => agentStateRef.current, [])\n\n    return {\n        agentState,\n        agentControls: {\n            moveForward,\n            moveBackward,\n            turnLeft,\n            turnRight,\n            pickUp,\n            dropOff,\n            getPos,\n        }\n    }\n}\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\executeCommand.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Map.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\levelContext.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\index.js",[],["112","113"],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\App.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\blockly\\robotCommandGenerator.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\blockly\\customBlocks.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\interpreter\\executeCommand.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Scene.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\levelContext.js",["114"],"import React from \"react\";\nimport * as THREE from \"three\";\n\nexport const GRID_W = 8;\nexport const GRID_H = 8;\n\nconst CELL_SIZE = 1.0;\nconst HALF = CELL_SIZE / 2;\n\nexport const CELL = {\n  EMPTY: \"empty\",\n  WALL: \"wall\",\n  PICKUP: \"pickup\",\n  DROPOFF: \"dropoff\",\n};\n\nexport function makeInitialGrid() {\n  const g = Array.from({ length: GRID_H }, () =>\n    Array.from({ length: GRID_W }, () => ({ type: CELL.EMPTY }))\n  );\n  g[2][3] = { type: CELL.WALL, meta: { height: 1.2 } };\n  g[1][1] = { type: CELL.PICKUP, meta: { id: \"P1\" } };\n  g[6][6] = { type: CELL.DROPOFF, meta: { id: \"D1\" } };\n  g[7][2] = { type: CELL.WALL };\n  g[0][4] = { type: CELL.WALL };\n  g[3][7] = { type: CELL.WALL };\n  return g;\n}\n\nfunction isEmptyXml(xmlConfig) {\n  const trimmedXml = xmlConfig.trim();\n  \n  // Проверяем через regexp, что XML содержит только теги <xml></xml> без вложенных блоков\n  // Разрешаем параметры в тегах, но не вложенные блоки\n  const emptyXmlRegex = /^<xml[^>]*><\\/xml>$/;\n  \n  return trimmedXml === '' || emptyXmlRegex.test(trimmedXml);\n}\n\nconst LevelContext = React.createContext(null);\n\nexport function LevelProvider({ children, levelId = 1 }) {\n  const [grid, setGrid] = React.useState(makeInitialGrid);\n  const [isLoading, setIsLoading] = React.useState(true);\n  const [xmlAlgorithmConfig, setXmlAlgorithmConfig] = React.useState('<xml></xml>');\n  const [isLevelCompleted, setIsLevelCompleted] = React.useState(false);\n\n  // Инициализация уровня\n  React.useEffect(() => {\n    setIsLoading(true);\n    setGrid(makeInitialGrid());\n    setIsLoading(false);\n  }, [levelId]);\n\n  // Утилиты, которые используют значения из контекста\n  const contextUtils = {\n    // Упрощенная версия gridToWorld\n    gridToWorld: (x, y) => new THREE.Vector3(\n      x * CELL_SIZE + HALF,\n      0,\n      (GRID_H - 1 - y) * CELL_SIZE + HALF\n    ),\n    \n    // Упрощенная версия getCellType\n    getCellType: (i, j) => {\n      if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) return null;\n      return grid[j][i]?.type ?? null;\n    },\n    \n    // Упрощенная версия isAdjacentToCellType\n    isAdjacentToCellType: (i, j, type) => {\n      const neighbors = [\n        { i: i + 1, j },\n        { i: i - 1, j },\n        { i, j: j + 1 },\n        { i, j: j - 1 }\n      ];\n      for (const { i: ni, j: nj } of neighbors) {\n        if (ni < 0 || ni >= GRID_W || nj < 0 || nj >= GRID_H) continue;\n        const cellType = grid[nj][ni]?.type ?? null;\n        if (cellType === type) return true;\n      }\n      return false;\n    },\n    \n    // Упрощенные версии isAdjacentToPickup и isAdjacentToDropoff\n    isAdjacentToPickup: (i, j) => contextUtils.isAdjacentToCellType(i, j, CELL.PICKUP),\n    isAdjacentToDropoff: (i, j) => contextUtils.isAdjacentToCellType(i, j, CELL.DROPOFF),\n    \n    // Упрощенная версия canEnterWorld\n    canEnterWorld: (x, y) => {\n      const i = Math.round(x + GRID_W / 2 - 0.5);\n      const zCell = Math.round(y + GRID_H / 2 - 0.5);\n      const j = GRID_H - 1 - zCell;\n      if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) return false;\n      const cell = grid[j][i];\n      return cell.type !== CELL.WALL;\n    },\n    \n    // Упрощенная версия canEnterLogical\n    canEnterLogical: (i, j) => {\n      if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) return false;\n      const cell = grid[j][i];\n      return cell.type !== CELL.WALL;\n    },\n    \n    // Упрощенная версия isWallAt\n    isWallAt: (i, j) => {\n      if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) return false;\n      const cellType = grid[j][i]?.type ?? null;\n      return cellType === CELL.WALL;\n    },\n\n    // Сброс уровня к начальному состоянию\n    resetLevel: () => {\n      setGrid(makeInitialGrid());\n      setXmlAlgorithmConfig('<xml></xml>');\n      setIsLevelCompleted(false);\n      return true;\n    },\n\n    // Отметить уровень как пройденный\n    markLevelCompleted: () => {\n      setIsLevelCompleted(true);\n      return true;\n    },\n\n    initAlgorithmConfig: () => {\n      let levelId = localStorage.getItem(`CurrentLevel`);\n      if (!levelId) {\n        levelId = 1\n        localStorage.setItem(`CurrentLevel`, 1);\n      }\n      \n      let xmlConfig = localStorage.getItem(`SavedAlgorithm/Level-${levelId}`);\n      if (!xmlConfig) {\n        localStorage.setItem(`SavedAlgorithm/Level-${levelId}`, '<xml></xml>');\n        xmlConfig = '<xml></xml>';\n      }\n      \n      return xmlConfig;\n    },\n\n    updateAlgorithmConfig: (xmlConfig) => {\n      let levelId = localStorage.getItem(`CurrentLevel`);\n      if (!levelId) {\n        return;\n      }\n      \n      localStorage.setItem(`SavedAlgorithm/Level-${levelId}`, xmlConfig);\n    }\n  };\n\n  const levelUtils = {\n    ...contextUtils,\n    CELL,\n    CELL_SIZE,\n    HALF\n  };\n\n  return (\n    <LevelContext.Provider value={{ \n      grid, \n      setGrid, \n      xmlAlgorithmConfig,\n      isLoading,\n      isLevelCompleted,\n      levelId,\n      ...levelUtils \n    }}>\n      {children}\n    </LevelContext.Provider>\n  );\n}\n\nexport function useLevel() {\n  const context = React.useContext(LevelContext);\n  if (!context) {\n    throw new Error(\"useLevel must be used within LevelProvider\");\n  }\n  return context;\n}\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\interpreter\\useCommandQueue.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\useAgent.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\agentContext.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Map.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\userContext.js",[],["115","116"],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Camera.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\components\\Onboarding.js",["117","118"],{"ruleId":"119","replacedBy":"120"},{"ruleId":"121","replacedBy":"122"},{"ruleId":"123","severity":1,"message":"124","line":20,"column":13,"nodeType":"125","messageId":"126","endLine":20,"endColumn":17},{"ruleId":"119","replacedBy":"127"},{"ruleId":"121","replacedBy":"128"},{"ruleId":"123","severity":1,"message":"129","line":30,"column":10,"nodeType":"125","messageId":"126","endLine":30,"endColumn":20},{"ruleId":"119","replacedBy":"130"},{"ruleId":"121","replacedBy":"131"},{"ruleId":"132","severity":1,"message":"133","line":79,"column":15,"nodeType":"134","endLine":79,"endColumn":84},{"ruleId":"132","severity":1,"message":"133","line":86,"column":15,"nodeType":"134","endLine":86,"endColumn":44},"no-native-reassign",["135"],"no-negated-in-lhs",["136"],"no-unused-vars","'grid' is assigned a value but never used.","Identifier","unusedVar",["135"],["136"],"'isEmptyXml' is defined but never used.",["135"],["136"],"jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","no-global-assign","no-unsafe-negation"]