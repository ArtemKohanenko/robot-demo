[{"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\index.js":"1","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\App.js":"2","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\levelContext.js":"3","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Scene.js":"4","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\blockly\\robotCommandGenerator.js":"5","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\interpreter\\executeCommand.js":"6","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\interpreter\\useCommandQueue.js":"7","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\blockly\\customBlocks.js":"8","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\gestureContext.js":"9","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\components\\Onboarding.js":"10","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\components\\GestureDetector.js":"11","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\agentContext.js":"12","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Map.js":"13","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\useAgent.js":"14","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Camera.js":"15","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\components\\GestureRecognition.js":"16","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\utils\\gestureFeatures.js":"17","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\utils\\indexedDB.js":"18"},{"size":219,"mtime":1760960974426,"results":"19","hashOfConfig":"20"},{"size":6081,"mtime":1761291282205,"results":"21","hashOfConfig":"20"},{"size":5438,"mtime":1760966518247,"results":"22","hashOfConfig":"20"},{"size":8578,"mtime":1761116830356,"results":"23","hashOfConfig":"20"},{"size":3595,"mtime":1761291282207,"results":"24","hashOfConfig":"20"},{"size":3344,"mtime":1761291282213,"results":"25","hashOfConfig":"20"},{"size":2601,"mtime":1761291282214,"results":"26","hashOfConfig":"20"},{"size":6290,"mtime":1761291282207,"results":"27","hashOfConfig":"20"},{"size":10687,"mtime":1761291282215,"results":"28","hashOfConfig":"20"},{"size":3800,"mtime":1761291282213,"results":"29","hashOfConfig":"20"},{"size":5089,"mtime":1761291282210,"results":"30","hashOfConfig":"20"},{"size":321,"mtime":1760673826148,"results":"31","hashOfConfig":"20"},{"size":2355,"mtime":1761112524581,"results":"32","hashOfConfig":"20"},{"size":6356,"mtime":1760965639409,"results":"33","hashOfConfig":"20"},{"size":8316,"mtime":1761114429042,"results":"34","hashOfConfig":"20"},{"size":14760,"mtime":1761291282211,"results":"35","hashOfConfig":"20"},{"size":7890,"mtime":1761291282216,"results":"36","hashOfConfig":"20"},{"size":2778,"mtime":1761291282216,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"6r85av",{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"40"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"40"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"40"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"40"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\index.js",[],["80","81"],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\App.js",["82"],"import { BlocklyWorkspace } from \"react-blockly\"\nimport \"./App.css\";\nimport \"./blockly/customBlocks\";\nimport { createGestureBlocks, getGestureBlockTypes } from \"./blockly/customBlocks\";\nimport RobotCommandGenerator, { registerGestureGenerators } from \"./blockly/robotCommandGenerator\";\nimport { useRef, useState, useEffect, useCallback, useMemo } from \"react\";\nimport { Scene } from \"./three/Scene\";\nimport executeCommand from \"./interpreter/executeCommand\";\nimport { useCommandQueue } from \"./interpreter/useCommandQueue\";\nimport { LevelProvider, useLevel } from \"./state/levelContext\";\nimport { GestureProvider, useGesture } from \"./state/gestureContext\";\nimport Onboarding from \"./components/Onboarding\";\nimport { GestureDetector } from \"./components/GestureDetector\";\nconst baseFlyoutToolbox = {\n  kind: \"flyoutToolbox\",\n  contents: [\n    {\n    kind: \"block\",\n    type: \"move_forward\",\n    },\n    {\n      kind: \"block\",\n      type: \"move_backward\",\n    },\n    {\n      kind: \"block\",\n      type: \"turn_right\",\n    },\n    {\n      kind: \"block\",\n      type: \"turn_left\",\n    },\n    {\n      kind: \"block\",\n      type: \"pickup\",\n    },\n    {\n      kind: \"block\",\n      type: \"dropoff\",\n    },\n    {\n      kind: \"block\",\n      type: \"wait\",\n    },\n    {\n      kind: \"block\",\n      type: \"repeat_n_times\",\n    },\n    {\n      kind: \"block\",\n      type: \"if_then\",\n    },\n    {\n      kind: \"block\",\n      type: \"is_wall_ahead\"\n    },\n    {\n      kind: \"block\",\n      type: \"if_gesture_then\",\n    }\n  ],\n};\n\nfunction AppContent() {\n  const workspaceRef = useRef(null);\n  const { updateAlgorithmConfig, initAlgorithmConfig, isLevelCompleted } = useLevel();\n  const { gestureState } = useGesture();\n  const initXmlAlgorithmConfig = initAlgorithmConfig();\n\n  const [gestureDetectorState, setGestureDetectorState] = useState({\n    isActive: false,\n    targetGesture: null,\n    resolveGesture: null,\n  });\n\n  // Создаем gestureHandler для работы с жестами в executeCommand\n  const gestureHandlerRef = useRef({\n    waitForGesture: (targetGestureName) => {\n      return new Promise((resolve) => {\n        setGestureDetectorState({\n          isActive: true,\n          targetGesture: targetGestureName,\n          resolveGesture: resolve,\n        });\n      });\n    }\n  });\n\n  const gestureHandler = gestureHandlerRef.current;\n\n  const handleGestureDetected = useCallback((detected) => {\n    setGestureDetectorState(prev => {\n      if (prev.resolveGesture) {\n        prev.resolveGesture(detected);\n      }\n      return {\n        isActive: false,\n        targetGesture: null,\n        resolveGesture: null,\n      };\n    });\n  }, []);\n\n  const handleCloseGestureDetector = useCallback(() => {\n    setGestureDetectorState(prev => {\n      if (prev.resolveGesture) {\n        prev.resolveGesture(false);\n      }\n      return {\n        isActive: false,\n        targetGesture: null,\n        resolveGesture: null,\n      };\n    });\n  }, []);\n\n  const [state, api] = useCommandQueue(executeCommand, gestureHandler);\n\n  // Создаём toolbox с динамическими блоками жестов\n  const flyoutToolbox = useMemo(() => {\n    const toolbox = { ...baseFlyoutToolbox };\n    \n    if (gestureState.gestureClasses && gestureState.gestureClasses.length > 0) {\n      // Создаём блоки для каждого жеста\n      createGestureBlocks(gestureState.gestureClasses);\n      registerGestureGenerators(gestureState.gestureClasses);\n      \n      // Добавляем блоки жестов в toolbox\n      const gestureBlockTypes = getGestureBlockTypes(gestureState.gestureClasses);\n      const gestureBlocks = gestureBlockTypes.map(type => ({\n        kind: \"block\",\n        type: type\n      }));\n      \n      toolbox.contents = [...baseFlyoutToolbox.contents, ...gestureBlocks];\n    }\n    \n    return toolbox;\n  }, [gestureState.gestureClasses]);\n\n  // Ключ для пересоздания workspace при изменении жестов\n  const workspaceKey = useMemo(() => {\n    return `workspace-${gestureState.gestureClasses.length}`;\n  }, [gestureState.gestureClasses]);\n\n  function workspaceDidChange(workspace) {\n    workspaceRef.current = workspace;\n  }\n\n  return (\n    <div className=\"flex-row full-size\">\n      <div className=\"flex-1 flex-col\">\n      <BlocklyWorkspace\n          key={workspaceKey}\n          toolboxConfiguration={flyoutToolbox}\n          initialXml={initXmlAlgorithmConfig}\n          onXmlChange={updateAlgorithmConfig}\n          className=\"fill-height blockly-workspace-container\"\n          workspaceConfiguration={{\n            renderer: 'thrasos',\n            grid: {\n              spacing: 20,\n              length: 3,\n              colour: \"#ccc\",\n              snap: true,\n            },\n            scrollbars: true,\n            toolbox: {\n              autoClose: false\n            }\n          }}\n          onWorkspaceChange={workspaceDidChange}\n        />\n        <div className=\"horizontal-controls\">\n          \n        </div>\n      </div>\n      <div className=\"scene-panel\">\n        <div className=\"scene-container\">\n          <Scene />\n        </div>\n        <button \n            className=\"executeButton\"\n            disabled={state.status === \"running\"}\n            onClick={\n              () => {\n                const workspace = workspaceRef.current;\n                const code = RobotCommandGenerator.workspaceToCode(workspace);\n                const commands = code.split('\\n')\n                api.run(commands);\n              }\n          }>{state.status === \"running\" ? \"Waiting...\" : \"Execute\"}</button>\n        <Onboarding isCompleted={isLevelCompleted} />\n      </div>\n      {gestureDetectorState.isActive && (\n        <GestureDetector\n          targetGesture={gestureDetectorState.targetGesture}\n          onGestureDetected={handleGestureDetected}\n          onClose={handleCloseGestureDetector}\n        />\n      )}\n    </div>\n  );\n}\n\nexport default function App() {\n  return (\n    <GestureProvider>\n      <LevelProvider>\n        <AppContent />\n      </LevelProvider>\n    </GestureProvider>\n  );\n}\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\levelContext.js",["83"],"import React from \"react\";\nimport * as THREE from \"three\";\n\nexport const GRID_W = 8;\nexport const GRID_H = 8;\n\nconst CELL_SIZE = 1.0;\nconst HALF = CELL_SIZE / 2;\n\nexport const CELL = {\n  EMPTY: \"empty\",\n  WALL: \"wall\",\n  PICKUP: \"pickup\",\n  DROPOFF: \"dropoff\",\n};\n\nexport function makeInitialGrid() {\n  const g = Array.from({ length: GRID_H }, () =>\n    Array.from({ length: GRID_W }, () => ({ type: CELL.EMPTY }))\n  );\n  g[2][3] = { type: CELL.WALL, meta: { height: 1.2 } };\n  g[1][1] = { type: CELL.PICKUP, meta: { id: \"P1\" } };\n  g[6][6] = { type: CELL.DROPOFF, meta: { id: \"D1\" } };\n  g[7][2] = { type: CELL.WALL };\n  g[0][4] = { type: CELL.WALL };\n  g[3][7] = { type: CELL.WALL };\n  return g;\n}\n\nfunction isEmptyXml(xmlConfig) {\n  const trimmedXml = xmlConfig.trim();\n  \n  // Проверяем через regexp, что XML содержит только теги <xml></xml> без вложенных блоков\n  // Разрешаем параметры в тегах, но не вложенные блоки\n  const emptyXmlRegex = /^<xml[^>]*><\\/xml>$/;\n  \n  return trimmedXml === '' || emptyXmlRegex.test(trimmedXml);\n}\n\nconst LevelContext = React.createContext(null);\n\nexport function LevelProvider({ children, levelId = 1 }) {\n  const [grid, setGrid] = React.useState(makeInitialGrid);\n  const [isLoading, setIsLoading] = React.useState(true);\n  const [xmlAlgorithmConfig, setXmlAlgorithmConfig] = React.useState('<xml></xml>');\n  const [isLevelCompleted, setIsLevelCompleted] = React.useState(false);\n\n  // Инициализация уровня\n  React.useEffect(() => {\n    setIsLoading(true);\n    setGrid(makeInitialGrid());\n    setIsLoading(false);\n  }, [levelId]);\n\n  // Утилиты, которые используют значения из контекста\n  const contextUtils = {\n    // Упрощенная версия gridToWorld\n    gridToWorld: (x, y) => new THREE.Vector3(\n      x * CELL_SIZE + HALF,\n      0,\n      (GRID_H - 1 - y) * CELL_SIZE + HALF\n    ),\n    \n    // Упрощенная версия getCellType\n    getCellType: (i, j) => {\n      if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) return null;\n      return grid[j][i]?.type ?? null;\n    },\n    \n    // Упрощенная версия isAdjacentToCellType\n    isAdjacentToCellType: (i, j, type) => {\n      const neighbors = [\n        { i: i + 1, j },\n        { i: i - 1, j },\n        { i, j: j + 1 },\n        { i, j: j - 1 }\n      ];\n      for (const { i: ni, j: nj } of neighbors) {\n        if (ni < 0 || ni >= GRID_W || nj < 0 || nj >= GRID_H) continue;\n        const cellType = grid[nj][ni]?.type ?? null;\n        if (cellType === type) return true;\n      }\n      return false;\n    },\n    \n    // Упрощенные версии isAdjacentToPickup и isAdjacentToDropoff\n    isAdjacentToPickup: (i, j) => contextUtils.isAdjacentToCellType(i, j, CELL.PICKUP),\n    isAdjacentToDropoff: (i, j) => contextUtils.isAdjacentToCellType(i, j, CELL.DROPOFF),\n    \n    // Упрощенная версия canEnterWorld\n    canEnterWorld: (x, y) => {\n      const i = Math.round(x + GRID_W / 2 - 0.5);\n      const zCell = Math.round(y + GRID_H / 2 - 0.5);\n      const j = GRID_H - 1 - zCell;\n      if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) return false;\n      const cell = grid[j][i];\n      return cell.type !== CELL.WALL;\n    },\n    \n    // Упрощенная версия canEnterLogical\n    canEnterLogical: (i, j) => {\n      if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) return false;\n      const cell = grid[j][i];\n      return cell.type !== CELL.WALL;\n    },\n    \n    // Упрощенная версия isWallAt\n    isWallAt: (i, j) => {\n      if (i < 0 || i >= GRID_W || j < 0 || j >= GRID_H) return false;\n      const cellType = grid[j][i]?.type ?? null;\n      return cellType === CELL.WALL;\n    },\n\n    // Сброс уровня к начальному состоянию\n    resetLevel: () => {\n      setGrid(makeInitialGrid());\n      setXmlAlgorithmConfig('<xml></xml>');\n      setIsLevelCompleted(false);\n      return true;\n    },\n\n    // Отметить уровень как пройденный\n    markLevelCompleted: () => {\n      setIsLevelCompleted(true);\n      return true;\n    },\n\n    initAlgorithmConfig: () => {\n      let levelId = localStorage.getItem(`CurrentLevel`);\n      if (!levelId) {\n        levelId = 1\n        localStorage.setItem(`CurrentLevel`, 1);\n      }\n      \n      let xmlConfig = localStorage.getItem(`SavedAlgorithm/Level-${levelId}`);\n      if (!xmlConfig) {\n        localStorage.setItem(`SavedAlgorithm/Level-${levelId}`, '<xml></xml>');\n        xmlConfig = '<xml></xml>';\n      }\n      \n      return xmlConfig;\n    },\n\n    updateAlgorithmConfig: (xmlConfig) => {\n      let levelId = localStorage.getItem(`CurrentLevel`);\n      if (!levelId) {\n        return;\n      }\n      \n      localStorage.setItem(`SavedAlgorithm/Level-${levelId}`, xmlConfig);\n    }\n  };\n\n  const levelUtils = {\n    ...contextUtils,\n    CELL,\n    CELL_SIZE,\n    HALF\n  };\n\n  return (\n    <LevelContext.Provider value={{ \n      grid, \n      setGrid, \n      xmlAlgorithmConfig,\n      isLoading,\n      isLevelCompleted,\n      levelId,\n      ...levelUtils \n    }}>\n      {children}\n    </LevelContext.Provider>\n  );\n}\n\nexport function useLevel() {\n  const context = React.useContext(LevelContext);\n  if (!context) {\n    throw new Error(\"useLevel must be used within LevelProvider\");\n  }\n  return context;\n}\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Scene.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\blockly\\robotCommandGenerator.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\interpreter\\executeCommand.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\interpreter\\useCommandQueue.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\blockly\\customBlocks.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\gestureContext.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\components\\Onboarding.js",["84","85"],"import React, { useState, useRef, useEffect } from 'react';\r\nimport GestureRecognition from './GestureRecognition';\r\nimport './Onboarding.css';\r\n\r\nfunction Onboarding({ isCompleted = false }) {\r\n  const [currentPage, setCurrentPage] = useState(0);\r\n  const [isModalOpen, setIsModalOpen] = useState(false);\r\n  const modalRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    const handleClickOutside = (event) => {\r\n      if (modalRef.current && !modalRef.current.contains(event.target)) {\r\n        setIsModalOpen(false);\r\n      }\r\n    };\r\n\r\n    if (isModalOpen) {\r\n      document.addEventListener('mousedown', handleClickOutside);\r\n    }\r\n\r\n    return () => {\r\n      document.removeEventListener('mousedown', handleClickOutside);\r\n    };\r\n  }, [isModalOpen]);\r\n\r\n  const pages = [\r\n    {\r\n      title: 'Шаг 1/3',\r\n      text: [\r\n        'Задание: добраться до дома робота-Профессора, чтобы забрать посылку',\r\n        'Для этого нужно сделать 5 шагов вперед.',\r\n        'Шаги измеряются в клеточках (1 клетка = 1 шаг).'\r\n      ]\r\n    },\r\n    {\r\n      title: 'Шаг 2/3',\r\n      text: [\r\n        'Перенеси блоки на холст',\r\n        'План для блоков:',\r\n        'Когда нажимаешь ',\r\n        'Сделать 5 шагов'\r\n      ]\r\n    },\r\n    {\r\n      title: 'Шаг 3/3',\r\n      text: [\r\n        'Нажми кнопку “Запустить”, программа запустится '\r\n      ]\r\n    }\r\n  ];\r\n\r\n  const completedPage = {\r\n    title: 'Шаг 3/3',\r\n    text: [\r\n        'Ты прошёл уровень, молодец!'\r\n    ]\r\n  }\r\n\r\n  const goToPrevPage = () => {\r\n    if (currentPage > 0) {\r\n      setCurrentPage(currentPage - 1);\r\n    }\r\n  };\r\n\r\n  const goToNextPage = () => {\r\n    if (currentPage < pages.length - 1) {\r\n      setCurrentPage(currentPage + 1);\r\n    }\r\n  };\r\n\r\n  const displayPage = isCompleted ? completedPage : pages[currentPage];\r\n\r\n  return (\r\n    <div className=\"gesture-onboarding-container\">\r\n      <h2 className=\"onboarding-title\">{displayPage.title}</h2>\r\n      <div className=\"onboarding-text\">\r\n        {displayPage.text.map((paragraph, index) => (\r\n          <p key={index} className=\"onboarding-paragraph\">{paragraph}</p>\r\n        ))}\r\n      </div>\r\n      \r\n      <div className=\"onboarding-footer\">\r\n        {\r\n          isCompleted ?\r\n            <div className=\"onboarding-navigation\">\r\n              <button \r\n                className=\"done-button\"\r\n              >\r\n                ✓ Готово\r\n              </button>\r\n            </div>\r\n          :\r\n          <div className=\"onboarding-navigation\">\r\n              <button \r\n                className=\"nav-button\"\r\n                onClick={goToPrevPage}\r\n                disabled={currentPage === 0}\r\n              >\r\n                <img src=\"images/Arrow.svg\" style={{ transform: 'rotate(180deg)' }}/>\r\n              </button>\r\n              <button \r\n                className=\"nav-button\"\r\n                onClick={goToNextPage}\r\n                disabled={currentPage === pages.length - 1}\r\n              >\r\n                <img src=\"images/Arrow.svg\"/>\r\n              </button>\r\n            </div>\r\n        }\r\n        \r\n        {/* Add Gesture button */}\r\n        <button \r\n          className=\"add-gesture-button\"\r\n          onClick={() => setIsModalOpen(true)}\r\n        >\r\n          Add Gesture\r\n        </button>\r\n      </div>\r\n      \r\n      {/* Modal */}\r\n      {isModalOpen && (\r\n        <div className=\"modal-overlay\">\r\n          <div className=\"modal-content\" ref={modalRef}>\r\n            <GestureRecognition />\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Onboarding;\r\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\components\\GestureDetector.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\state\\agentContext.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Map.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\useAgent.js",[],["86","87"],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\three\\Camera.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\components\\GestureRecognition.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\utils\\gestureFeatures.js",["88"],"/**\n * Улучшенное извлечение признаков для распознавания жестов\n * Создает признаки инвариантные к позиции, размеру и частично к повороту руки\n */\n\n/**\n * Вычисляет евклидово расстояние между двумя точками\n */\nfunction distance(p1, p2) {\n  const dx = p1.x - p2.x;\n  const dy = p1.y - p2.y;\n  const dz = (p1.z || 0) - (p2.z || 0);\n  return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n\n/**\n * Вычисляет угол между тремя точками (в радианах)\n * angle = arccos((BA · BC) / (|BA| × |BC|))\n */\nfunction angle(p1, p2, p3) {\n  // Векторы от p2 к p1 и от p2 к p3\n  const v1 = {\n    x: p1.x - p2.x,\n    y: p1.y - p2.y,\n    z: (p1.z || 0) - (p2.z || 0)\n  };\n  const v2 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y,\n    z: (p3.z || 0) - (p2.z || 0)\n  };\n  \n  // Скалярное произведение\n  const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n  \n  // Длины векторов\n  const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);\n  const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);\n  \n  if (len1 === 0 || len2 === 0) return 0;\n  \n  // Косинус угла\n  const cosAngle = dot / (len1 * len2);\n  // Ограничиваем значение для избежания ошибок округления\n  const clampedCos = Math.max(-1, Math.min(1, cosAngle));\n  \n  return Math.acos(clampedCos);\n}\n\n/**\n * Извлекает улучшенные признаки из ключевых точек руки\n * MediaPipe Hand landmarks: 21 точка\n * \n * Индексы точек:\n * 0: Запястье (WRIST)\n * 1-4: Большой палец (THUMB_CMC, MCP, IP, TIP)\n * 5-8: Указательный (INDEX_FINGER_MCP, PIP, DIP, TIP)\n * 9-12: Средний (MIDDLE_FINGER_MCP, PIP, DIP, TIP)\n * 13-16: Безымянный (RING_FINGER_MCP, PIP, DIP, TIP)\n * 17-20: Мизинец (PINKY_MCP, PIP, DIP, TIP)\n */\nexport function extractGestureFeatures(keypoints) {\n  if (!keypoints || keypoints.length !== 21) {\n    throw new Error('Требуется 21 ключевая точка руки');\n  }\n  \n  const features = [];\n  \n  // 1. Нормализация по размеру руки\n  // Используем расстояние от запястья (0) до среднего пальца MCP (9)\n  const wrist = keypoints[0];\n  const middleFingerBase = keypoints[9];\n  const handSize = distance(wrist, middleFingerBase);\n  \n  // Защита от деления на ноль\n  const normFactor = handSize > 0.01 ? handSize : 1;\n  \n  // 2. Нормализованные координаты относительно запястья\n  // Это делает признаки инвариантными к позиции руки в кадре\n  for (let i = 1; i < 21; i++) {\n    const kp = keypoints[i];\n    features.push(\n      (kp.x - wrist.x) / normFactor,\n      (kp.y - wrist.y) / normFactor,\n      ((kp.z || 0) - (wrist.z || 0)) / normFactor\n    );\n  }\n  // 20 точек × 3 координаты = 60 признаков\n  \n  // 3. Углы в суставах пальцев\n  // Большой палец\n  features.push(angle(keypoints[1], keypoints[2], keypoints[3])); // CMC-MCP-IP\n  features.push(angle(keypoints[2], keypoints[3], keypoints[4])); // MCP-IP-TIP\n  \n  // Указательный палец\n  features.push(angle(keypoints[5], keypoints[6], keypoints[7])); // MCP-PIP-DIP\n  features.push(angle(keypoints[6], keypoints[7], keypoints[8])); // PIP-DIP-TIP\n  \n  // Средний палец\n  features.push(angle(keypoints[9], keypoints[10], keypoints[11]));\n  features.push(angle(keypoints[10], keypoints[11], keypoints[12]));\n  \n  // Безымянный палец\n  features.push(angle(keypoints[13], keypoints[14], keypoints[15]));\n  features.push(angle(keypoints[14], keypoints[15], keypoints[16]));\n  \n  // Мизинец\n  features.push(angle(keypoints[17], keypoints[18], keypoints[19]));\n  features.push(angle(keypoints[18], keypoints[19], keypoints[20]));\n  // 10 углов\n  \n  // 4. Расстояния между кончиками пальцев (нормализованные)\n  // Это помогает различать жесты типа \"ок\", \"peace\" и т.д.\n  const fingerTips = [4, 8, 12, 16, 20]; // Кончики всех пальцев\n  \n  for (let i = 0; i < fingerTips.length; i++) {\n    for (let j = i + 1; j < fingerTips.length; j++) {\n      const dist = distance(keypoints[fingerTips[i]], keypoints[fingerTips[j]]);\n      features.push(dist / normFactor);\n    }\n  }\n  // C(5,2) = 10 расстояний\n  \n  // 5. Расстояния от кончиков пальцев до запястья (нормализованные)\n  for (const tipIndex of fingerTips) {\n    const dist = distance(keypoints[tipIndex], wrist);\n    features.push(dist / normFactor);\n  }\n  // 5 расстояний\n  \n  // 6. Углы между векторами пальцев (от основания к кончику)\n  const fingerBases = [1, 5, 9, 13, 17]; // Основания пальцев\n  \n  for (let i = 0; i < fingerBases.length; i++) {\n    for (let j = i + 1; j < fingerBases.length; j++) {\n      const baseI = fingerBases[i];\n      const tipI = fingerTips[i];\n      const baseJ = fingerBases[j];\n      const tipJ = fingerTips[j];\n      \n      features.push(angle(\n        keypoints[tipI],\n        keypoints[baseI],\n        keypoints[tipJ]\n      ));\n    }\n  }\n  // C(5,2) = 10 углов\n  \n  // Итого: 60 + 10 + 10 + 5 + 10 = 95 признаков\n  // Больше чем 63, но гораздо информативнее!\n  \n  return features;\n}\n\n/**\n * Альтернативная версия с меньшим количеством признаков (для более быстрой работы)\n * Используйте эту версию если производительность критична\n */\nexport function extractGestureFeaturesLight(keypoints) {\n  if (!keypoints || keypoints.length !== 21) {\n    throw new Error('Требуется 21 ключевая точка руки');\n  }\n  \n  const features = [];\n  \n  // Нормализация\n  const wrist = keypoints[0];\n  const middleFingerBase = keypoints[9];\n  const handSize = distance(wrist, middleFingerBase);\n  const normFactor = handSize > 0.01 ? handSize : 1;\n  \n  // 1. Нормализованные координаты (60 признаков)\n  for (let i = 1; i < 21; i++) {\n    const kp = keypoints[i];\n    features.push(\n      (kp.x - wrist.x) / normFactor,\n      (kp.y - wrist.y) / normFactor,\n      ((kp.z || 0) - (wrist.z || 0)) / normFactor\n    );\n  }\n  \n  // 2. Только углы в суставах (10 признаков)\n  features.push(angle(keypoints[1], keypoints[2], keypoints[3]));\n  features.push(angle(keypoints[2], keypoints[3], keypoints[4]));\n  features.push(angle(keypoints[5], keypoints[6], keypoints[7]));\n  features.push(angle(keypoints[6], keypoints[7], keypoints[8]));\n  features.push(angle(keypoints[9], keypoints[10], keypoints[11]));\n  features.push(angle(keypoints[10], keypoints[11], keypoints[12]));\n  features.push(angle(keypoints[13], keypoints[14], keypoints[15]));\n  features.push(angle(keypoints[14], keypoints[15], keypoints[16]));\n  features.push(angle(keypoints[17], keypoints[18], keypoints[19]));\n  features.push(angle(keypoints[18], keypoints[19], keypoints[20]));\n  \n  // Итого: 70 признаков (компромисс между качеством и скоростью)\n  \n  return features;\n}\n\n/**\n * Выбор версии функции извлечения признаков\n * По умолчанию используется полная версия\n */\nexport default extractGestureFeatures;\n\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\yandex-uchebnik-robots-web\\src\\utils\\indexedDB.js",[],{"ruleId":"89","replacedBy":"90"},{"ruleId":"91","replacedBy":"92"},{"ruleId":"93","severity":1,"message":"94","line":6,"column":28,"nodeType":"95","messageId":"96","endLine":6,"endColumn":37},{"ruleId":"93","severity":1,"message":"97","line":30,"column":10,"nodeType":"95","messageId":"96","endLine":30,"endColumn":20},{"ruleId":"98","severity":1,"message":"99","line":99,"column":17,"nodeType":"100","endLine":99,"endColumn":86},{"ruleId":"98","severity":1,"message":"99","line":106,"column":17,"nodeType":"100","endLine":106,"endColumn":46},{"ruleId":"89","replacedBy":"101"},{"ruleId":"91","replacedBy":"102"},{"ruleId":"93","severity":1,"message":"103","line":138,"column":13,"nodeType":"95","messageId":"96","endLine":138,"endColumn":18},"no-native-reassign",["104"],"no-negated-in-lhs",["105"],"no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'isEmptyXml' is defined but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement",["104"],["105"],"'baseJ' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]