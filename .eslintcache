[{"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\index.js":"1","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\App.js":"2","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\robotCommandGenerator.js":"3","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\customBlocks.js":"4","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\useCommandQueue.js":"5","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\agentContext.js":"6","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Scene.js":"7","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\useAgent.js":"8","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\executeCommand.js":"9","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Map.js":"10"},{"size":219,"mtime":1760352187013,"results":"11","hashOfConfig":"12"},{"size":2286,"mtime":1760361723669,"results":"13","hashOfConfig":"12"},{"size":1885,"mtime":1760360337320,"results":"14","hashOfConfig":"12"},{"size":3745,"mtime":1760352187010,"results":"15","hashOfConfig":"12"},{"size":2427,"mtime":1760361042177,"results":"16","hashOfConfig":"12"},{"size":285,"mtime":1760422215243,"results":"17","hashOfConfig":"12"},{"size":2076,"mtime":1760437462991,"results":"18","hashOfConfig":"12"},{"size":3366,"mtime":1760429705144,"results":"19","hashOfConfig":"12"},{"size":584,"mtime":1760360541381,"results":"20","hashOfConfig":"12"},{"size":4381,"mtime":1760436583489,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"125b5e2",{"filePath":"25","messages":"26","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"24"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"24"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"24"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"24"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"24"},"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\index.js",[],["48","49"],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\App.js",["50"],"import { BlocklyWorkspace } from \"react-blockly\"\nimport \"./App.css\";\nimport \"./blockly/customBlocks\";\nimport { useRef } from \"react\";\nimport { Scene } from \"./three/Scene\";\nimport RobotCommandGenerator from \"./blockly/robotCommandGenerator\";\nimport executeCommand from \"./interpreter/executeCommand\";\nimport { useCommandQueue } from \"./interpreter/useCommandQueue\";\n\nconst initialXml = '<xml></xml>';\nconst flyoutToolbox = {\nkind: \"flyoutToolbox\",\ncontents: [\n    {\n    kind: \"block\",\n    type: \"move_forward\",\n    },\n    {\n    kind: \"block\",\n    type: \"move_backward\",\n    },\n    {\n    kind: \"block\",\n    type: \"turn_right\",\n    },\n    {\n    kind: \"block\",\n    type: \"turn_left\",\n    },\n    {\n    kind: \"block\",\n    type: \"repeat_n_times\",\n    },\n    {\n    kind: \"block\",\n    type: \"if_then\",\n    }\n  ],\n};\n\nexport default function App() {\n  const workspaceRef = useRef(null);\n\n  const [state, api] = useCommandQueue(executeCommand);\n\n  function workspaceDidChange(workspace) {\n    workspaceRef.current = workspace;\n  }\n\n  return (\n    <div className=\"flex-row full-size\">\n      <div className=\"flex-1 flex-col\">\n      <BlocklyWorkspace\n          key=\"flyout-only\"\n          toolboxConfiguration={flyoutToolbox}\n          initialXml={initialXml}\n          className=\"fill-height blockly-workspace-container\"\n          workspaceConfiguration={{\n            grid: {\n              spacing: 20,\n              length: 3,\n              colour: \"#ccc\",\n              snap: true,\n            },\n            scrollbars: true,\n            toolbox: {\n              autoClose: false\n            }\n          }}\n          onWorkspaceChange={workspaceDidChange}\n        />\n        <div className=\"horizontal-controls\">\n          \n        </div>\n      </div>\n      <div className=\"scene-panel\">\n        <div className=\"scene-container\">\n          <Scene />\n        </div>\n        <button \n            className=\"executeButton\"\n            onClick={\n              () => {\n                const workspace = workspaceRef.current;\n                const code = RobotCommandGenerator.workspaceToCode(workspace);\n                const commands = code.split('\\n')\n                api.setQueue(commands);\n                api.start();\n              }\n          }>Execute</button>\n      </div>\n    </div>\n  );\n}\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\robotCommandGenerator.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\blockly\\customBlocks.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\useCommandQueue.js",["51"],"import React from 'react';\r\nimport { agentControls } from '../state/agentContext'\r\n\r\nexport function useCommandQueue(executor) {\r\n  const [state, setState] = React.useState({\r\n    queue: [],\r\n    current: null,\r\n    status: \"idle\",\r\n    error: undefined,\r\n  });\r\n\r\n  const cancelCurrentRef = React.useRef(null);\r\n\r\n  const enqueue = React.useCallback((cmd) => {\r\n    setState(prev => ({\r\n      ...prev,\r\n      queue: [...prev.queue, cmd],\r\n    }));\r\n  }, []);\r\n\r\n  const setQueue = React.useCallback((cmds) => {\r\n    setState(prev => ({\r\n      ...prev,\r\n      queue: cmds\r\n    }));\r\n  }, []);\r\n\r\n  const start = React.useCallback(() => {\r\n    setState(prev => {\r\n      if (prev.status === \"running\") return prev;\r\n      return { ...prev, status: \"running\" };\r\n    });\r\n  }, []);\r\n\r\n  const pause = React.useCallback(() => {\r\n    if (cancelCurrentRef.current) {\r\n      cancelCurrentRef.current();\r\n    }\r\n    setState(prev => ({ ...prev, status: \"paused\" }));\r\n  }, []);\r\n\r\n  const resume = React.useCallback(() => {\r\n    setState(prev => {\r\n      if (prev.status === \"paused\") {\r\n        return { ...prev, status: \"running\" };\r\n      }\r\n      return prev;\r\n    });\r\n  }, []);\r\n\r\n  const stop = React.useCallback(() => {\r\n    if (cancelCurrentRef.current) {\r\n      cancelCurrentRef.current();\r\n    }\r\n    setState({\r\n      queue: [],\r\n      current: null,\r\n      status: \"idle\",\r\n      error: undefined,\r\n    });\r\n  }, []);\r\n\r\n  // Queue processing\r\n  React.useEffect(() => {\r\n    if (state.status !== \"running\") return;\r\n    if (state.current) return;\r\n    if (state.queue.length === 0) {\r\n      setState(prev => ({ ...prev, status: \"idle\" }));\r\n      return;\r\n    }\r\n\r\n    const [next, ...rest] = state.queue;\r\n    setState(prev => ({ ...prev, current: next, queue: rest }));\r\n\r\n    let canceled = false;\r\n    const cancelFunc = () => {\r\n      canceled = true;\r\n    };\r\n    cancelCurrentRef.current = cancelFunc;\r\n\r\n    executor(next, agentControls)\r\n      .then(() => {\r\n        if (canceled) return;\r\n        cancelCurrentRef.current = null;\r\n        setState(prev => ({ ...prev, current: null }));\r\n      })\r\n      .catch(err => {\r\n        if (canceled) return;\r\n        cancelCurrentRef.current = null;\r\n        setState(prev => ({ ...prev, status: \"error\", error: err }));\r\n      });\r\n  }, [state.status, state.queue, state.current, executor]);\r\n\r\n  return [state, { enqueue, setQueue, start, pause, resume, stop }];\r\n}\r\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\state\\agentContext.js",["52"],"import React, { createContext } from \"react\";\r\n\r\nexport const AgentContext = createContext(null);\r\n\r\nexport const agentControls = {\r\n  moveForward: () => {},\r\n  moveBackward: () => {},\r\n  turnLeft: () => {},\r\n  turnRight: () => {},\r\n  getPos: () => ({ x: 0, y: 0, direction: 0 })\r\n};\r\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Scene.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\useAgent.js",["53","54"],"import { useState, useRef, useCallback } from 'react'\r\n\r\nconst DIRECTIONS = [\r\n    { dx: 0, dy: 1 },   // 0 - вверх\r\n    { dx: 1, dy: 0 },   // 1 - вправо\r\n    { dx: 0, dy: -1 },  // 2 - вниз\r\n    { dx: -1, dy: 0 },  // 3 - влево\r\n]\r\n\r\nconst DIRECTION_COUNT = DIRECTIONS.length\r\n\r\nexport function useAgent({\r\n    mapWidth,\r\n    mapHeight,\r\n    agentRadius = 0.5,\r\n    steps = 20,\r\n    duration = 300\r\n} = {}) {\r\n    const [agentState, setAgentState] = useState(() => ({\r\n        x: -mapWidth / 2 + agentRadius,\r\n        y: -mapHeight / 2 + agentRadius,\r\n        direction: 1\r\n    }))\r\n    const agentStateRef = useRef(agentState)\r\n    agentStateRef.current = agentState\r\n\r\n    const animateMove = useCallback(async (to) => {\r\n        const from = { ...agentStateRef.current }\r\n        let dDir = ((to.direction - from.direction + DIRECTION_COUNT) % DIRECTION_COUNT)\r\n        if (dDir > 2) dDir -= DIRECTION_COUNT\r\n        const dx = to.x - from.x\r\n        const dy = to.y - from.y\r\n        for (let step = 1; step <= steps; ++step) {\r\n            await new Promise(res => setTimeout(res, duration / steps))\r\n            const t = step / steps\r\n            const x = from.x + dx * t\r\n            const y = from.y + dy * t\r\n            let newDir = (from.direction + dDir * t + DIRECTION_COUNT) % DIRECTION_COUNT\r\n            setAgentState({ x, y, direction: t < 1 ? newDir : to.direction })\r\n        }\r\n        setAgentState(to)\r\n    }, [steps, duration])\r\n\r\n    const moveForward = useCallback(async () => {\r\n        const { x, y, direction } = agentStateRef.current\r\n        const { dx, dy } = DIRECTIONS[direction]\r\n        let newX = x + dx\r\n        let newY = y + dy\r\n        newX = Math.max(-mapWidth/2 + agentRadius, Math.min(mapWidth/2 - agentRadius, newX))\r\n        newY = Math.max(-mapHeight/2 + agentRadius, Math.min(mapHeight/2 - agentRadius, newY))\r\n        if (newX !== x || newY !== y)\r\n            await animateMove({ x: newX, y: newY, direction })\r\n    }, [animateMove, mapWidth, mapHeight])\r\n\r\n    const moveBackward = useCallback(async () => {\r\n        const { x, y, direction } = agentStateRef.current\r\n        const { dx, dy } = DIRECTIONS[direction]\r\n        let newX = x - dx\r\n        let newY = y - dy\r\n        newX = Math.max(-mapWidth/2 + agentRadius, Math.min(mapWidth/2 - agentRadius, newX))\r\n        newY = Math.max(-mapHeight/2 + agentRadius, Math.min(mapHeight/2 - agentRadius, newY))\r\n        if (newX !== x || newY !== y)\r\n            await animateMove({ x: newX, y: newY, direction })\r\n    }, [animateMove, mapWidth, mapHeight])\r\n\r\n    const turnLeft = useCallback(async () => {\r\n        const { x, y, direction } = agentStateRef.current\r\n        const newDir = (direction + DIRECTION_COUNT - 1) % DIRECTION_COUNT\r\n        await animateMove({ x, y, direction: newDir })\r\n    }, [animateMove])\r\n\r\n    const turnRight = useCallback(async () => {\r\n        const { x, y, direction } = agentStateRef.current\r\n        const newDir = (direction + 1) % DIRECTION_COUNT\r\n        await animateMove({ x, y, direction: newDir })\r\n    }, [animateMove])\r\n\r\n    const getPos = useCallback(() => agentStateRef.current, [])\r\n\r\n    return {\r\n        agentState,\r\n        agentControls: {\r\n            moveForward,\r\n            moveBackward,\r\n            turnLeft,\r\n            turnRight,\r\n            getPos,\r\n        }\r\n    }\r\n}\r\n","C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\interpreter\\executeCommand.js",[],"C:\\Users\\abdulb\\source\\repos\\Effective\\Yandex\\reactblockly-customblocks\\src\\three\\Map.js",["55","56","57","58"],"import * as THREE from \"three\";\r\nimport React from 'react';\r\n\r\n\r\nconst GRID_W = 10;\r\nconst GRID_H = 8;\r\nconst CELL_SIZE = 1.0;\r\nconst HALF = CELL_SIZE / 2;\r\nconst MOVE_DURATION = 0.18;\r\n\r\nexport const CELL_KINDS = {\r\n    EMPTY: \"empty\",\r\n    OBSTACLE: \"obstacle\",\r\n    PICKUP: \"pickup\",\r\n    DROPOFF: \"dropoff\",\r\n};\r\n\r\nconst CELL = {\r\n  EMPTY: \"empty\",\r\n  WALL: \"wall\",\r\n  WATER: \"water\",\r\n  PICKUP: \"pickup\",\r\n  DROPOFF: \"dropoff\",\r\n};\r\n\r\n  \r\n\r\nfunction gridToWorld(x, y) {\r\n    return new THREE.Vector3(x * CELL_SIZE + HALF, 0, y * CELL_SIZE + HALF);\r\n  }\r\n\r\nfunction worldToGrid(vec3) {\r\n    const gx = Math.floor(vec3.x / CELL_SIZE);\r\n    const gy = Math.floor(vec3.z / CELL_SIZE);\r\n    return { gx, gy };\r\n}\r\n\r\nfunction makeInitialGrid() {\r\n  const g = Array.from({ length: GRID_H }, () =>\r\n    Array.from({ length: GRID_W }, () => ({ type: CELL.EMPTY }))\r\n  );\r\n\r\n  // Пример: разные препятствия и точки\r\n  g[2][3] = { type: CELL.WALL, meta: { height: 1.2 } };\r\n  g[4][5] = { type: CELL.WATER, meta: { depth: 0.2 } };\r\n  g[1][1] = { type: CELL.PICKUP, meta: { id: \"P1\" } };\r\n  g[6][8] = { type: CELL.DROPOFF, meta: { id: \"D1\" } };\r\n\r\n  // ещё пара стен\r\n  g[0][4] = { type: CELL.WALL };\r\n  g[3][7] = { type: CELL.WALL };\r\n\r\n  return g;\r\n}\r\n\r\n\r\nfunction canMoveTo(grid, x, y) {\r\n    if (x < 0 || y < 0 || x >= GRID_W || y >= GRID_H) return false;\r\n    if (grid[y][x] === 1) return false; // блок\r\n    return true;\r\n}\r\n\r\nfunction GridVisual({ grid }) {\r\n    const cells = [];\r\n    for (let j = 0; j < GRID_H; j++) {\r\n      for (let i = 0; i < GRID_W; i++) {\r\n        const cell = grid[j][i];\r\n        const world = gridToWorld(i, j);\r\n        // базовая плитка\r\n        cells.push(\r\n          <mesh\r\n            key={`tile-${i}-${j}`}\r\n            position={[world.x, 0, world.z]}\r\n            rotation={[-Math.PI / 2, 0, 0]}\r\n          >\r\n            <planeGeometry args={[CELL_SIZE * 0.98, CELL_SIZE * 0.98]} />\r\n            <meshStandardMaterial\r\n              // чуть разный цвет для контраста\r\n              color={cell.type === CELL.WATER ? \"#91b5ff\" : \"#e6e6e6\"}\r\n              transparent={cell.type === CELL.WATER}\r\n              opacity={cell.type === CELL.WATER ? 0.9 : 1}\r\n            />\r\n          </mesh>\r\n        );\r\n  \r\n        // отображаем объекты поверх плитки\r\n        if (cell.type === CELL.WALL) {\r\n          const h = (cell.meta && cell.meta.height) || 1.0;\r\n          cells.push(\r\n            <mesh key={`wall-${i}-${j}`} position={[world.x, h / 2, world.z]}>\r\n              <boxGeometry args={[CELL_SIZE * 0.9, h, CELL_SIZE * 0.9]} />\r\n              <meshStandardMaterial color=\"#8b5a3c\" />\r\n            </mesh>\r\n          );\r\n        } else if (cell.type === CELL.WATER) {\r\n          const d = (cell.meta && cell.meta.depth) || 0.2;\r\n          cells.push(\r\n            <mesh key={`water-${i}-${j}`} position={[world.x, 0.01, world.z]}>\r\n              <cylinderGeometry args={[CELL_SIZE * 0.45, CELL_SIZE * 0.45, d, 6]} />\r\n              <meshStandardMaterial color=\"#4da6ff\" transparent opacity={0.6} />\r\n            </mesh>\r\n          );\r\n        } else if (cell.type === CELL.PICKUP) {\r\n          // маркер пункта получения — зелёный цилиндр и метка\r\n          cells.push(\r\n            <group key={`pickup-${i}-${j}`} position={[world.x, 0.05, world.z]}>\r\n              <cylinderGeometry args={[0.18, 0.18, 0.12, 16]} />\r\n              <meshStandardMaterial attach=\"material\" color=\"#2ecc71\" />\r\n            </group>\r\n          );\r\n        } else if (cell.type === CELL.DROPOFF) {\r\n          // маркер сдачи — конус / тор\r\n          cells.push(\r\n            <group key={`drop-${i}-${j}`} position={[world.x, 0.05, world.z]}>\r\n              <coneGeometry args={[0.18, 0.25, 16]} />\r\n              <meshStandardMaterial color=\"#e76f51\" />\r\n            </group>\r\n          );\r\n        }\r\n      }\r\n    }\r\n    return <group>{cells}</group>;\r\n}\r\n  \r\n  \r\n\r\nexport function Map({ width, height }) {\r\n  const [grid, setGrid] = React.useState(makeInitialGrid());\r\n\r\n  return (\r\n      <mesh position={[0, 0, 0]}>\r\n          <planeGeometry args={[width, height]} />\r\n          {/* <meshBasicMaterial color=\"green\" /> */}\r\n          <GridVisual grid={grid} />\r\n      </mesh>\r\n  )\r\n}\r\n  ",{"ruleId":"59","replacedBy":"60"},{"ruleId":"61","replacedBy":"62"},{"ruleId":"63","severity":1,"message":"64","line":44,"column":10,"nodeType":"65","messageId":"66","endLine":44,"endColumn":15},{"ruleId":"67","severity":1,"message":"68","line":92,"column":6,"nodeType":"69","endLine":92,"endColumn":58,"suggestions":"70"},{"ruleId":"63","severity":1,"message":"71","line":1,"column":8,"nodeType":"65","messageId":"66","endLine":1,"endColumn":13},{"ruleId":"67","severity":1,"message":"72","line":53,"column":8,"nodeType":"69","endLine":53,"endColumn":42,"suggestions":"73"},{"ruleId":"67","severity":1,"message":"72","line":64,"column":8,"nodeType":"69","endLine":64,"endColumn":42,"suggestions":"74"},{"ruleId":"63","severity":1,"message":"75","line":9,"column":7,"nodeType":"65","messageId":"66","endLine":9,"endColumn":20},{"ruleId":"63","severity":1,"message":"76","line":32,"column":10,"nodeType":"65","messageId":"66","endLine":32,"endColumn":21},{"ruleId":"63","severity":1,"message":"77","line":57,"column":10,"nodeType":"65","messageId":"66","endLine":57,"endColumn":19},{"ruleId":"63","severity":1,"message":"78","line":128,"column":16,"nodeType":"65","messageId":"66","endLine":128,"endColumn":23},"no-native-reassign",["79"],"no-negated-in-lhs",["80"],"no-unused-vars","'state' is assigned a value but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook React.useEffect has a missing dependency: 'state'. Either include it or remove the dependency array. Mutable values like 'state.current' aren't valid dependencies because mutating them doesn't re-render the component.","ArrayExpression",["81"],"'React' is defined but never used.","React Hook useCallback has a missing dependency: 'agentRadius'. Either include it or remove the dependency array.",["82"],["83"],"'MOVE_DURATION' is assigned a value but never used.","'worldToGrid' is defined but never used.","'canMoveTo' is defined but never used.","'setGrid' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"84","fix":"85"},{"desc":"86","fix":"87"},{"desc":"86","fix":"88"},"Update the dependencies array to be: [state.status, state.queue, executor, state]",{"range":"89","text":"90"},"Update the dependencies array to be: [mapWidth, agentRadius, mapHeight, animateMove]",{"range":"91","text":"92"},{"range":"93","text":"92"},[2296,2348],"[state.status, state.queue, executor, state]",[1972,2006],"[mapWidth, agentRadius, mapHeight, animateMove]",[2526,2560]]